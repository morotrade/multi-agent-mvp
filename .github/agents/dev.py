#!/usr/bin/env python3
import os
import httpx
import subprocess
from utils import (
    get_github_headers, call_llm_api, slugify,
    validate_diff_files, extract_single_diff, apply_diff_resilient,
    get_repo_language, get_preferred_model,
    get_issue_node_id, add_item_to_project, set_project_single_select
)

REPO = os.environ["GITHUB_REPOSITORY"]
ISSUE_NUMBER = os.environ["ISSUE_NUMBER"]
ISSUE_TITLE = os.environ["ISSUE_TITLE"]
ISSUE_BODY = os.environ.get("ISSUE_BODY", "")

# Fallback minimale per quando l'LLM non produce diff validi
def create_fallback_diff() -> str:
    """Crea un diff minimale per evitare failure totali"""
    owner = REPO.split("/")[0] if "/" in REPO else "Project"
    from datetime import datetime
    year = str(datetime.utcnow().year)
    
    return f"""--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,3 @@
+MIT License
+
+Copyright (c) {year} {owner}
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software."""

def get_issue_details() -> dict:
    """Recupera i dettagli dell'issue"""
    url = f"https://api.github.com/repos/{REPO}/issues/{ISSUE_NUMBER}"

    with httpx.Client(timeout=30) as client:
        response = client.get(url, headers=get_github_headers())
        response.raise_for_status()

    return response.json()

def create_branch(branch_name: str) -> None:
    """Crea un nuovo branch"""
    subprocess.run(["git", "checkout", "-b", branch_name], check=True, capture_output=True)

def generate_implementation(issue_details: dict) -> str:
    """Genera l'implementazione usando AI"""
    try:
        with open(".github/prompts/dev.md", "r", encoding="utf-8") as f:
            prompt_template = f.read()
    except FileNotFoundError:
        prompt_template = (
            "# Ruolo: Senior Developer\n"
            "Implementa la funzionalità richiesta seguendo le best practices del linguaggio {language}."
        )

    language = get_repo_language()
    prompt = prompt_template.replace("{language}", language)

    prompt += (
        f"\n\n## ISSUE DA IMPLEMENTARE:\n"
        f"**Titolo:** {issue_details['title']}\n"
        f"**Descrizione:** {issue_details.get('body', 'Nessuna descrizione')}\n\n"
        f"## ISTRUZIONI:\n"
        f"1. Implementa SOLO ciò che è specificato nell'issue\n"
        f"2. Segui le convenzioni di codice del progetto\n"
        f"3. Mantieni le modifiche minimali e focalizzate\n"
        f"4. Non modificare file non rilevanti\n\n"
        f"## OUTPUT:\n"
        f"Fornisci il codice in un singolo blocco ```diff. Non includere altro testo.\n\n"
        f"```diff\n"
    )

    model = get_preferred_model("developer")
    return call_llm_api(prompt, model=model, max_tokens=6000)

def safe_git_push(branch_name: str) -> bool:
    """Push del branch con gestione degli errori"""
    try:
        # Debug: verifica configurazione git
        result = subprocess.run(["git", "remote", "-v"], capture_output=True, text=True)
        print(f"🔍 Git remotes: {result.stdout}")
        
        # Debug: verifica branch
        result = subprocess.run(["git", "branch", "-a"], capture_output=True, text=True)
        print(f"🔍 Git branches: {result.stdout}")
        
        # Prova il push
        result = subprocess.run(
            ["git", "push", "origin", branch_name], 
            capture_output=True, text=True, check=False
        )
        
        if result.returncode == 0:
            print(f"✅ Push riuscito: {branch_name}")
            return True
        else:
            print(f"❌ Push fallito. STDOUT: {result.stdout}")
            print(f"❌ Push fallito. STDERR: {result.stderr}")
            return False
            
    except Exception as e:
        print(f"❌ Errore durante push: {e}")
        return False

def create_pr(branch_name: str, issue_number: str, issue_title: str) -> dict:
    """Crea una Pull Request - con gestione graceful del 403"""
    pr_data = {
        "title": f"[Bot] Implement: {issue_title}",
        "head": branch_name,
        "base": "main",
        "body": (
            f"Implementazione automatica dell'issue #{issue_number}\n\n"
            f"## Changes\n"
            f"- Implementata richiesta: {issue_title}\n\n"
            f"Closes #{issue_number}\n\n"
            f"---\n*Auto-generated by AI Developer*"
        )
    }

    url = f"https://api.github.com/repos/{REPO}/pulls"

    with httpx.Client(timeout=30) as client:
        response = client.post(url, headers=get_github_headers(), json=pr_data)
        
        if response.status_code == 403:
            print("⚠️ Permessi insufficienti per creare PR automaticamente")
            print(f"🔗 Branch creato: {branch_name}")
            print(f"💡 Crea manualmente la PR da GitHub web interface")
            return {"html_url": f"https://github.com/{REPO}/compare/{branch_name}"}
        
        response.raise_for_status()

    return response.json()

def main():
    global ISSUE_TITLE  # Dichiara global all'inizio della funzione
    
    try:
        print("🧑‍💻 Avvio AI Developer...")

        # Recupera dettagli issue
        issue = get_issue_details()
        print(f"📋 Issue: {issue['title']}")
        
        # === Project linkage ===
        owner, repo = REPO.split("/")
        project_id = os.environ.get("GITHUB_PROJECT_ID")
        status_field_id = os.environ.get("PROJECT_STATUS_FIELD_ID")
        status_inprogress = os.environ.get("PROJECT_STATUS_INPROGRESS_ID")

        try:
            if project_id and status_field_id and status_inprogress:
                issue_node_id = get_issue_node_id(owner, repo, int(ISSUE_NUMBER))
                item_id = add_item_to_project(project_id, issue_node_id)
                set_project_single_select(project_id, item_id, status_field_id, status_inprogress)
                print(f"📌 Issue #{ISSUE_NUMBER} aggiunta al Project e impostata su 'In progress'")
            else:
                print("ℹ️ Project linkage skipped (vars mancanti).")
        except Exception as e:
            print(f"⚠️ Project linkage error: {e}")


        # Crea branch
        branch_name = f"bot/issue-{ISSUE_NUMBER}-{slugify(ISSUE_TITLE)}"
        create_branch(branch_name)
        print(f"🌿 Branch creato: {branch_name}")

        # Genera implementazione
        print("🛠️ Generazione implementazione...")
        implementation = generate_implementation(issue)

        # Estrai e valida il diff
        print("🔍 Estrazione e validazione del diff...")
        try:
            diff_content = extract_single_diff(implementation)
            validate_diff_files(diff_content)
        except Exception as e:
            print(f"⚠️ LLM output non valido ({e}), uso fallback LICENSE...")
            diff_content = create_fallback_diff()
            # Nota nel commit che è un fallback
            ISSUE_TITLE = f"{ISSUE_TITLE} (fallback: added LICENSE)"

        # Applica il diff
        print("📝 Applicazione del diff...")
        success = apply_diff_resilient(diff_content)
        if not success:
            raise Exception("Impossibile applicare il diff")

        # Commit e push
        print("💾 Commit delle modifiche...")
        subprocess.run(["git", "add", "."], check=True, capture_output=True)
        subprocess.run([
            "git", "commit", "-m",
            f"feat: implement issue #{ISSUE_NUMBER} - {ISSUE_TITLE}"
        ], check=True, capture_output=True)

        print("📤 Push del branch...")
        push_success = safe_git_push(branch_name)
        
        if not push_success:
            print("⚠️ Push fallito, ma branch e commit locali creati")
            print(f"🔗 Controlla manualmente: https://github.com/{REPO}")
            return

        # Crea PR (con gestione graceful del 403)
        print("🚀 Creazione della Pull Request...")
        pr = create_pr(branch_name, ISSUE_NUMBER, ISSUE_TITLE)
        print(f"✅ Risultato: {pr['html_url']}")

        # Torna al branch main
        subprocess.run(["git", "checkout", "main"], capture_output=True)

    except Exception as e:
        print(f"❌ Errore: {str(e)}")

        # Ripristina lo stato pulito
        try:
            subprocess.run(["git", "reset", "--hard"], capture_output=True)
            subprocess.run(["git", "clean", "-fd"], capture_output=True)
            subprocess.run(["git", "checkout", "main"], capture_output=True)
        except:
            pass

        raise

if __name__ == "__main__":
    main()